"""Generates a makefile for a CFS application

Usage
python genMakeFile.py
    Generates a makefile for the app contained within the apps
    directory which contains this script.
python genMakeFile.py /path/to/apps/dir/of/target/app
    Generates a makefile for the app contained within the apps
    directory passed as an argument.
    
This script must EITHER:
    - Be stored within the apps directory for which you wish 
    to generate a makefile (usually saved in 
    <app_name>/fsw/for_build)
    - Be called with the path of the target directory as the 
    first argument (any path within the app directory is fine)
"""


import os
import sys

# define makefile contents with format replacements
makefile_contents = """###############################################################################
# File: CFS Application Makefile 
#
# $Id: Makefile 1.5 2009/07/09 10:41:16GMT-05:00 rmcgraw Exp  $
#
# $Log: Makefile  $
# Revision 1.5 2009/07/09 10:41:16GMT-05:00 rmcgraw 
# DCR8291:1 Changed CFE_MISSION_INC to CFS_MISSION_INC and added log if needed
#
#
# Generated by genMakeFile.py. Do not edit!!! Update the script!
#
###############################################################################
#
# Subsystem produced by this makefile.
#
APPTARGET = {appNameLower}

# 
# Entry Point for task
# 
ENTRY_PT = {appNameLower}_AppMain

#
# Object files required to build subsystem.
#
{objFiles}

#
# Source files required to build subsystem; used to generate dependencies.
# As long as there are no assembly files this can be automated.
#
SOURCES = $(OBJS:.o=.c)


##
## Specify extra C Flags needed to build this subsystem
##
LOCAL_COPTS = 


##
## EXEDIR is defined here, just in case it needs to be different for a custom
## build
##
EXEDIR=../exe

##
## Certain OSs and Application Loaders require the following option for
## Shared libraries. Currently only needed for vxWorks 5.5 and RTEMS.
## For each shared library that this app depends on, you need to have an
## entry like the following:
##  -R../tst_lib/tst_lib.elf
##
SHARED_LIB_LINK = 

########################################################################
# Should not have to change below this line, except for customized 
# Mission and cFE directory structures
########################################################################

#
# Set build type to CFE_APP. This allows us to 
# define different compiler flags for the cFE Core and Apps.
# 
BUILD_TYPE = CFE_APP

## 
## Include all necessary cFE make rules
## Any of these can be copied to a local file and 
## changed if needed.
##
##
##       cfe-config.mak contains PSP and OS selection
##
include ../cfe/cfe-config.mak
##
##       debug-opts.mak contains debug switches
##
include ../cfe/debug-opts.mak
##
##       compiler-opts.mak contains compiler definitions and switches/defines
##
include $(CFE_PSP_SRC)/$(PSP)/make/compiler-opts.mak

##
## Setup the include path for this subsystem
## The OS specific includes are in the build-rules.make file
##
## If this subsystem needs include files from another app, add the path here.
##
INCLUDE_PATH = \
-I$(OSAL_SRC)/inc \
-I$(CFE_CORE_SRC)/inc \
-I$(CFE_PSP_SRC)/inc \
-I$(CFE_PSP_SRC)/$(PSP)/inc \
-I$(CFS_APP_SRC)/inc \
-I$(CFS_APP_SRC)/$(APPTARGET)/fsw/src \
-I$(CFS_APP_SRC)/$(APPTARGET)/fsw/eci_inc \
-I$(CFS_APP_SRC)/$(APPTARGET)/fsw/mission_inc \
-I$(CFS_APP_SRC)/$(APPTARGET)/fsw/platform_inc \
-I$(CFS_APP_SRC)/eci/fsw/src \
-I$(CFS_APP_SRC)/eci/fsw/faultrep/ \
-I$(CFS_MISSION_INC) \
-I../cfe/inc \
-I../inc

##
## Define the VPATH make variable. 
## This can be modified to include source from another directory.
## If there is no corresponding app in the cfs-apps directory, then this can be discarded, or
## if the mission chooses to put the src in another directory such as "src", then that can be 
## added here as well.
##
VPATH := $(CFS_APP_SRC)/$(APPTARGET)/fsw/src 
VPATH += $(CFS_APP_SRC)/eci/fsw/src
VPATH += $(CFS_APP_SRC)/eci/fsw/faultrep

##
## Include the common make rules for building a cFE Application
##
include $(CFE_CORE_SRC)/make/app-rules.mak
"""

if __name__ == "__main__":

    # parse arguments
    # if provided, use the argument as the path containing
    # the app directory of the target apps
    if len(sys.argv) > 1:
        scriptPath = sys.argv[1]
    # otherwise use the location of this script
    else:
        scriptPath = os.path.realpath(__file__)

    # find apps dir within target path
    print("Found script path: {}".format(scriptPath))
    scriptPathList = scriptPath.split(os.sep)
    appIdx = scriptPathList.index("apps") + 1

    # error is there's no 'apps' directory within path, user
    # must've used this script incorrectly
    if appIdx is None:
        raise Exception("Could not find apps directory")

    # get apps path
    appPath = os.path.join(scriptPathList[0], *scriptPathList[1 : appIdx + 1])
    print('Found app path: "{}"'.format(appPath))

    # get app name based off directory name
    appNameLower = str(scriptPathList[appIdx]).lower()
    print('Found app name: "{}"'.format(appNameLower))

    # find src files of target app
    srcPath = os.path.join(appPath, "fsw", "src")
    print('Found src path: "{}"'.format(srcPath))
    sourceFiles = [f for f in os.listdir(srcPath) if f.endswith(".c")]
    objFilesList = [f.replace(".c", ".o") for f in sourceFiles]

    # make list of source files for the makefile
    objFilesStr = "OBJS := eci_app.o \nOBJS += app_faultrep.o \n"
    for file in objFilesList:
        objFilesStr += "OBJS += {}\n".format(file)
        print('Found source file: "{}"'.format(file))

    # write the makefile
    buildPath = os.path.join(appPath, "fsw", "for_build")
    print("Found buildPath path: {}".format(buildPath))
    outFileName = str(os.path.join(buildPath, "Makefile"))
    with open(outFileName, "w") as makefile:
        makefile.write(
            makefile_contents.format(appNameLower=appNameLower, objFiles=objFilesStr)
        )
